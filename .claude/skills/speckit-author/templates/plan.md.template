# Implementation Plan: {{TITLE}}

**Type:** {{WORKFLOW_TYPE}}
**Slug:** {{SLUG}}
**Date:** {{DATE}}

## Task Breakdown

### Phase 1: Foundation

#### Task impl_001: [Task Name]

**Estimated Time:** [Duration]
**Priority:** High | Medium | Low

**Files:**
- `src/path/file1.py`
- `src/path/file2.py`
- `tests/test_file.py`

**Description:**
[Detailed description of what needs to be implemented]

**Steps:**
1. [Step 1]
2. [Step 2]
3. [Step 3]

**Acceptance Criteria:**
- [ ] Criterion 1
- [ ] Criterion 2
- [ ] Criterion 3

**Verification:**
```bash
# Commands to verify implementation
uv run python -c "from src.module import Class; print('OK')"
uv run pytest tests/test_file.py -v
```

**Dependencies:**
- None (or list other task IDs)

---

#### Task impl_002: [Task Name]

**Estimated Time:** [Duration]
**Priority:** High | Medium | Low

**Files:**
- `src/path/file3.py`

**Description:**
[Detailed description]

**Steps:**
1. [Step 1]
2. [Step 2]

**Acceptance Criteria:**
- [ ] Criterion 1
- [ ] Criterion 2

**Verification:**
```bash
uv run pytest tests/test_file3.py
```

**Dependencies:**
- impl_001 (must complete first)

---

### Phase 2: Core Implementation

#### Task impl_003: [Task Name]

**Estimated Time:** [Duration]
**Priority:** High

**Files:**
- `src/core/module.py`
- `tests/test_module.py`

**Description:**
[Core business logic implementation]

**Steps:**
1. Create module structure
2. Implement core functionality
3. Add error handling
4. Write comprehensive tests

**Acceptance Criteria:**
- [ ] All business logic implemented
- [ ] Error cases handled
- [ ] Tests passing with >85% coverage

**Verification:**
```bash
uv run pytest tests/test_module.py --cov=src.core.module --cov-report=term
```

**Dependencies:**
- impl_001, impl_002

---

### Phase 3: API Layer

#### Task impl_004: [Task Name]

**Estimated Time:** [Duration]
**Priority:** High

**Files:**
- `src/api/routes.py`
- `src/api/models.py`
- `tests/test_api.py`

**Description:**
[API endpoint implementation]

**Steps:**
1. Define Pydantic models for request/response
2. Implement endpoint handlers
3. Add input validation
4. Write integration tests

**Acceptance Criteria:**
- [ ] Endpoints respond correctly
- [ ] Validation working
- [ ] Error responses formatted correctly
- [ ] Integration tests passing

**Verification:**
```bash
uv run pytest tests/test_api.py -v
# Manual test:
curl -X POST http://localhost:8000/api/endpoint -H "Content-Type: application/json" -d '{"field": "value"}'
```

**Dependencies:**
- impl_003

---

### Phase 4: Testing

#### Task test_001: Unit Tests

**Estimated Time:** [Duration]
**Priority:** High

**Files:**
- `tests/test_*.py`
- `tests/conftest.py`

**Description:**
Comprehensive unit tests for all modules.

**Coverage Targets:**
- Overall: ≥80%
- Core modules: ≥90%
- Utilities: ≥85%

**Steps:**
1. Set up pytest fixtures in conftest.py
2. Write unit tests for each module
3. Test happy paths and error conditions
4. Achieve coverage targets

**Verification:**
```bash
uv run pytest --cov=src --cov-report=term --cov-report=html
uv run pytest --cov=src --cov-fail-under=80
```

**Dependencies:**
- impl_001, impl_002, impl_003, impl_004

---

#### Task test_002: Integration Tests

**Estimated Time:** [Duration]
**Priority:** High

**Files:**
- `tests/integration/test_*.py`

**Description:**
End-to-end integration tests with real database.

**Steps:**
1. Set up test database fixtures
2. Test API workflows end-to-end
3. Test error scenarios
4. Test concurrent requests

**Verification:**
```bash
uv run pytest tests/integration/ -v
```

**Dependencies:**
- impl_004, test_001

---

### Phase 5: Containerization

#### Task container_001: Application Container

**Estimated Time:** [Duration]
**Priority:** Medium

**Files:**
- `Containerfile`
- `.containerignore`

**Description:**
Create optimized container for application.

**Steps:**
1. Write multi-stage Containerfile
2. Optimize layer caching
3. Add health check
4. Test container build and run

**Verification:**
```bash
podman build -t {{SLUG}}:latest .
podman run --rm -p 8000:8000 {{SLUG}}:latest
curl http://localhost:8000/health
```

**Dependencies:**
- All implementation tasks complete

---

#### Task container_002: Container Orchestration

**Estimated Time:** [Duration]
**Priority:** Medium

**Files:**
- `podman-compose.yml`
- `.env.example`

**Description:**
Set up multi-container orchestration.

**Steps:**
1. Define services in podman-compose.yml
2. Configure volumes and networks
3. Set up environment variables
4. Add health checks
5. Test full stack

**Verification:**
```bash
podman-compose up -d
podman-compose ps
curl http://localhost:8000/health
podman-compose logs app
podman-compose down
```

**Dependencies:**
- container_001

---

## Estimated Total Time

| Phase | Duration |
|-------|----------|
| Phase 1: Foundation | [X hours] |
| Phase 2: Core Implementation | [X hours] |
| Phase 3: API Layer | [X hours] |
| Phase 4: Testing | [X hours] |
| Phase 5: Containerization | [X hours] |
| **Total** | **[X hours]** |

## Task Dependencies Graph

```
impl_001 ─┐
          ├─> impl_003 ─> impl_004 ─┐
impl_002 ─┘                          ├─> test_001 ─> test_002 ─> container_001 ─> container_002
                                     │
                                     └─> test_001
```

## Critical Path

1. impl_001
2. impl_002
3. impl_003
4. impl_004
5. test_001
6. test_002
7. container_001
8. container_002

[Identify which tasks are on the critical path and cannot be parallelized]

## Parallel Work Opportunities

- impl_001 and impl_002 can be done in parallel
- test_001 unit tests can be written alongside implementation
- Documentation can be written in parallel with containerization

## Quality Checklist

Before considering this feature complete:

- [ ] All tasks marked as complete
- [ ] Test coverage ≥ 80%
- [ ] All tests passing (unit + integration)
- [ ] Linting clean (`uv run ruff check src/ tests/`)
- [ ] Type checking clean (`uv run mypy src/`)
- [ ] Container builds successfully
- [ ] Container health checks passing
- [ ] API documentation complete
- [ ] Code reviewed
- [ ] Manual testing performed

## Risk Assessment

### High Risk Tasks

- **impl_003**: Core business logic is complex
  - Mitigation: Break into smaller subtasks, pair programming

- **test_002**: Integration tests may be flaky
  - Mitigation: Use proper fixtures, isolated test database

### Medium Risk Tasks

- **container_002**: Multi-container networking can be tricky
  - Mitigation: Test thoroughly in local environment first

## Notes

[Any additional notes, considerations, or context for implementation]

### Implementation Tips

- [Tip 1]
- [Tip 2]
- [Tip 3]

### Common Pitfalls

- [Pitfall 1 and how to avoid it]
- [Pitfall 2 and how to avoid it]

### Resources

- [Link to relevant documentation]
- [Link to example code]
- [Link to design patterns]
